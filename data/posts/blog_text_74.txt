The popularity of Javascript (JS) has skyrocketed ever since it made the jump from the browser to the server-side (thank you Node.JS). Therefore a lot of the server-side work previously done in Java and other 'core' languages is now done in JS. This has resulted in a lot of Java developers (like me) taking a keen interest in JS.Things get really weird when you try and map a 'traditional' OO language (like Java) to a 'prototype' based OO language like JS. Not to mention functions that are really objects and can be passed as parameters.That is why I thought I would explore prototypes and functions in this post with some examples.Some concepts:1) Every function is an object! Let us see, with an example, the way JS treats functions.[codesyntax lang="javascript" lines="normal"]function Car(type) {this.type = type;//New function object is createdthis.getType = function(){return this.type;};}//Two new Car objectsvar merc = new Car("Merc");var bmw = new Car("BMW");/** Functions should be defined once and reused* but this proves that the two Car objects* have their own instance of the getType function*/if(bmw.getType == merc.getType){console.log(true);}else{//Output is falseconsole.log(false);}[/codesyntax]The output of the above code is 'false' thereby proving the two functions are actually different 'objects'. 2) Every function (as it is also an object) can have properties and methods. By default each function is created with a 'prototype' property which points to a special object that holds properties and methods that should be available to instances of the reference type.What does this really mean? Let us change the previous example to understand what's happening. Let us play with the prototype object and add a function to it which will be available to all the instances.[codesyntax lang="javascript" lines="normal"]function Car(type) {this.type = type;}Car.prototype.getType = function(){return this.type;}//Two new Car objectsvar merc = new Car("Merc");var bmw = new Car("BMW");/** Functions should be defined once and reused* This proves that the two Car objects* have the same instance of the getType function*/if(bmw.getType == merc.getType){//Output is trueconsole.log(true);}else{console.log(false);}[/codesyntax]We added the 'getType' function to the prototype object for the Car function. This makes it available to all instances of the Car function object. Therefore we can think of the prototype object as the core of a Function object. Methods and properties attached to this core are available to all the instances of the function Object.This core object (i.e. the prototype) can be manipulated in different ways to support OO behaviour (e.g. Inheritance). 3) Methods and properties can be added to both the core or the instance. This enables method over-riding as shown in the example below.[codesyntax lang="javascript" lines="normal"]function Car() {}//Adding a property and function to the prototypeCar.prototype.type = "BLANK";Car.prototype.getType = function(){return this.type;}//Two new Car objectsvar merc = new Car();var bmw = new Car();//Adding a property and a function to the INSTANCE (merc)merc.type = "Merc S-Class";merc.getType = function(){return "I own a "+this.type;}//Outputconsole.log("Merc Type: ", merc.getType());console.log("BMW Type: ", bmw.getType());console.log("Merc Object: ",merc);console.log("BMW Object: ",bmw);[/codesyntax] The output:Merc Type:  I own a Merc S-Class> This shows that the 'getType' on the instance is being called.BMW Type:  BLANK> This shows that the 'getType' on the prototype is being called.Merc Object:  { type: 'Merc S-Class', getType: [Function] }> This shows the 'merc' object structure in JSON format. We see the property and function on the instance.BMW Object:  {}> This shows the 'bmw' object structure in JSON format. We see there are no properties or functions attached to the instance.