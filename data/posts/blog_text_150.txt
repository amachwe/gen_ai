Artificial Neural Networks: An IntroductionArtificial Neural Networks: Problems with Multiple Hidden LayersArtificial Neural Networks: Introduction to Deep LearningArtificial Neural Networks: Restricted Boltzmann MachinesArtificial Neural Networks: Training for Deep Learning - IThis is the second post on Training a Deep Learning network. The best way to read through is by starting from the first post (see above).This post, like the series provides a pathway into deep learning by introducing some of the concepts using some common reference points. This is not designed to be an exhaustive research review of deep learning techniques. I have also tried to keep the description neutral of any programming language, though the backing code is written in Java.So far we have visited shallow neural networks and their building blocks (post 1), investigated their performance on difficult problems and explored their limitations (post 2). Then we jumped into the world of deep networks and described the concept behind them (post 3) and the RBM building block (post 4). Finally in the previous post we started describing a possible training method for such deep networks (post 5) where we take a local view of the network..In this post we describe the other side of the training process - where we take the global view of the network.Network Usage:Before we start that though, it is very important to take a step back and review what we are trying to do.Our target is to train a neural network that can be used to classify complex data to a high degree of accuracy for tasks that are relatively easy for Humans to do.Classification can be done in one of two ways: Discriminative or Generative. We have touched on these in the previous post as well. From a practical perspective the choice needs to be made on the basis of what we want our network to do. If we want to use it for a purely label generation task for an input then it is enough to have a discriminative model (which basically calculates p (label | input)). Here we are attempting to assign a label to a set of features extracted from the input. That is why discrimintative training requires labelled training data.If you want to actually create new inputs based on certain features then you need to have a generative model (which calculates p (label , input)). In case of a generative model we do not 'discriminate' between inputs based on features using labels (i.e. try and find the label/class boundary). Instead we treat them as a pair of variables and we try and model their joint probability. This allows us to create new pairs of inputs and features based on the learned joint probabilities.For example: if we are using MNIST just to recognise and label handwritten digits then we can work with a discriminative model. To get the discriminative output we need some sort of a 'capping' output layer (e.g. softmax) which gives us one clear label (for this example there is one to one correspondence between input and label). We cannot directly work with a probability distribution of features (similar to what we saw in the last post) as an output. The process here is inherently one way, present an input and get the label as an output (thus the propagation is away from the input layer).But what if we wanted to generate new 'handwritten' digits (think of an app that translates a typed letter into a handwritten one which matches your handwriting!). If we learn p(input , label)  we can easily reverse it as we could start with a label and get an 'input' (hand written digit). The direction of generative propagation is opposite to the discriminative one (the propagation is towards the input layer).Does this mean that we should always target a generative model as it gives us more flexibility? The short answer is No, because generative models usually have poor performance as compared to their discriminative cousins. The long answer is 'depends on the use-case'.Symbol Grounding Problem:Another reason why we show special interest in generative models is because the standard 'data' labeling process is very artificial. In real life no such clear labels exist for most of what we experience or even worse: there may be too many labels. For example if we show an image of a cartoon car to say 10 different people and ask them to assign one label to it we are more than likely to get multiple labels such as: cartoon car, car, cartoon... and that is just in the English language! If we had people in that group whose first language was not English they might use other labels which may or may not have a direct correlation with the corresponding English language labels. In fact all these labels are just different symbols that assign meaning to the data. This is the 'symbol grounding problem' in AI.Our brain definitely does not work with strict labels. In fact it matches the joint distribution behavior better - the cartoon in the above example can be analysed at different levels such as: a cartoon, a cartoon car, a cartoon sports car, a cartoon sports car driving very fast.... so as we analyse the same input we have a growing set of labels associated with it.It would be very messy if we had to learn a different discriminative model for each of the associated labels that operates on the same input data. Also it would be impossible if we were asked to draw a cartoon sports car without some kind of generative model that takes into account all its possible 'characteristics' and returns a learned representation (shape, components, size etc.).If we also take a look at human cognition (which is what we are trying to mimic) simple classification is just one half of the process. Without the generative ability we would not be able to react to the result of the classification. Our brain may classify the weather as 'likely to be wet' as the image of the sky travels from the eye to the brain, but it is the reverse propagation from the brain to our muscles that ensures we pick up the umbrella.For our example: As our brain classifies and breaks down the task of drawing a cartoon sports car it needs to switch into generative mode to actually draw it out.Here we also have a good reason why generative models should NOT be very accurate or rigid. If we had rigidly learnt generative models that did not change over time (or were very difficult to re-train), there would be no concept of 'training', 'skill' or 'creativity'. Given a set of features we all would produce the same (or similar) cartoon sports car! There would be very little difference between the cartoon sports car drawn by a professional cartoonist and one drawn by a child as after a certain point in time a rigid generative model would not respond to additional training.Note: the above description is an over-simplification of some very complex cognitive processes and is intended only as an aid in understanding the concepts being presented in this post.MNIST Example:We can generate digits as we learn to classify them using the greedy learning algorithm described in the previous post. This can be done by simply reversing the direction of propagation from Input => Hidden to Hidden => Input and doing some sampling using clamped hidden vectors.The process is very simple:Randomly generate a binary vector equal in length to the top most hidden layerClamp this vector to the hidden layer and then propagate down to the visible and back up to the hidden 'n' number of times (thus feeding back the result at both hidden and visible layers)For the last iteration do not propagate back to the hidden unit instead convert the vector on the visible layer into an imageFor the test we have the standard MNIST input layer (28 x 28 = 784 inputs). Following that we have 3 hidden layers of 100 neurons each. Each hidden layer is trained using CD-10 on a mini batch of the MNIST dataset. I will be uploading the associated test files on my github. The file is: rd.neuron.neuron.test.TestRBMMNISTRecipeWhen we set n = 0 we get very fuzzy generated digits:[caption id="attachment_497" align="aligncenter" width="280"] Generated Digits[/caption]I can make out a few rough 2s and a some half formed digits and a lot of '0's!Let us set n = 5 (therefore we do down - up for 5 times and then the 6th pass is just down):[caption id="attachment_498" align="aligncenter" width="280"] Generated Numbers 6[/caption]As you can see the generated digits are a lot cleaner and we also have some relatively complicated digits ('3' and '6') and a rough '8' (3rd row from bottom, 4th column from right).This proves that our network has learnt the features associated with handwritten digits which it uses to generate new data.As a final example, let us set n = 50 and generate a larger set of digits:[caption id="attachment_499" align="aligncenter" width="560"] Generated Digits 50[/caption]In the next post we delve deeper into the 'feature' - 'label' training process and show how we can get our deep network to classify hand-written digits.