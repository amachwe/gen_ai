The continue keyword in the Java programming language provides functionality to skip the current iteration of a loop. Unlike the break keyword which 'break' the execution flow out of the loop, continue allows us to skip an iteration. This functionality is often replicated using an if block as below:for(int i=0;i<100;i++) {     if(i%2==0){          // Execute the loop only for even values of i otherwise skip the iteration      }}The above piece of code can be re-written using the continue keyword:for(int i=0;i<100;i++) {     if(i%2!=0){           continue; //Skip the loop if i is odd      }     //Loop continues as normal if i is even} While this simple example might not bring out the power of the humble continue keyword, imagine if there were several conditions under which the iteration should be suspended. That would mean having a complicated set of nested if-else blocks to check the flow of execution within the iteration. Whereas with continue we just need to check the condition for skipping the iteration. There is no need for the else part.Another advantage of using continue  is that it allows the control to be transferred to a labelled statement, as we shall see in a bit.Before going further let me state the two different ways continue can be used:Form 1:   continue;Form 2:   continue <label>;Example:The scenario: Imagine you need to extract keywords from a text source. This is a multi-step process with the first step being converting the text into tokens (i.e. breaking down the paragraphs and sentences to individual words based on some rules). Then the set of tokens is filtered and common usage words, such as 'the', are removed (stop word removal). Following this you may again want to filter the set using a domain specific set of common use words or you may want to ignore the text source all-together (i.e. not process it) if it has certain words in it. For example if you are interested only in processing articles about Apple products you would want to ignore articles which talk about the fruit.As you might have guessed, the above process requires several iterations over different sets of data. This is where a continue statement would be most effective. The code given below shows how to use continue. Obviously there are several other ways of implementing the desired functionality (including not using continue). // Stop and ignore word listsstatic String stopWordList[] = { "at", "in", "the", "and", "if", "of","am", "who" };static String ignoreWordList[] = { "king", "queen" };------------------------------ // Sample stringsString samples[] = {"I am the king of the world!", "For I am the Red Queen", "A man who wasn't there" };outer: for (String sample : samples) {    System.out.println("Original String: " + sample + "\n");    // Create tokens    String[] tokens = tokenize(sample);    System.out.println("Unfiltered Tokens:");    printToken(tokens);    // Filter tokens on stop words   ArrayList<String> filteredTokens = new ArrayList<String>();    for (String token : tokens) {        if (filterStopWord(token)) {           continue; // ---------------- (1)       }        if (filterIgnoreWord(token)) {        System.out.println("Ignore - " + sample + "\n\n");          continue outer; // ---------- (2)       }       filteredTokens.add(token); // --- (3)    }    // Print filtered tokens   printToken(filteredTokens);   System.out.println("\n");}// End of outer: forThe full .java file can be found here (right click and save-as).The logic flow is as follows:1) Initialise a set of samples (can be any source - taken simple sentences for this example).2) The for loop labelled 'outer' iterates through the set of samples.3) Create unfiltered token set from the sample.4) Print the token set (unfiltered).5) Initialise array list to store the filtered set of tokens.6) Iterate through the unfiltered token set to filter out tokens.7) Within the iteration if the current token is a 'stop word' then skip the inner loop (using continue - line (1)) as it should not be added to filtered set.8) If the current token is not a 'stop word' then the current iteration will continue as normal.9) Next we check if the token is on the 'ignore' list, if it is then we stop processing the sample and skip the iteration of the outer for loop (using labelled continue - line (2)).10) If the token is not on the ignore list then we continue with the current iteration and add the token to the filtered set.If we run the above program with the required methods in place we will see the following output:Original String: I am the king of the world!Unfiltered Tokens:[I]  [am]  [the]  [king]  [of]  [the]  [world!]Ignore - I am the king of the world!Original String: For I am the Red QueenUnfiltered Tokens:[For]  [I]  [am]  [the]  [Red]  [Queen]Ignore - For I am the Red QueenOriginal String: A man who wasn't thereUnfiltered Tokens:[A]  [man]  [who]  [wasn't]  [there]Filtered Tokens:[A]  [man]  [wasn't]  [there]As per the logic, the first two samples are ignored and the third one is processed.