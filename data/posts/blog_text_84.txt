And we are not in Kansas any more!I wanted to talk about the new-ish  Apache Karaf  custom command system. Things have been made very easy using Annotations. It took me a while to get all the pieces together as most of the examples out there were using the deprecated Command system.To create a custom command in Karaf shell we need the following:Custom Command Class (one per Custom Command)Entry in the Manifest to indicate that Custom Commands are present (or the correct POM entry if using maven-bundle-plugin and package type of 'bundle')This is a lot simpler than before where multiple configuration settings were required to get a custom command to work.The Custom Command ClassThis is a class that contains the implementation of the command, it also contains the command definition (including the name, scope and arguments). We can also define custom 'completers' to allow tabbed command completion. This can be extended to provide state-based command completion (i.e. completion can adapt to what commands have been executed previously in the session).A new instance of the Custom Command Class is spun up every time the command is executed so it is inherently thread-safe, but we have to make sure any heavy lifting is not done directly by the Custom Command Class. [see here]AnnotationsThere are a few important annotations that we need to use to define our own commands:@CommandUsed to Annotate the Custom Command Class - this defines the command (name, scope etc.). @ServiceAfter the @Command, just before the Custom Command Class definition starts. Ensures there is a standard way of getting a reference to the custom command. @ArgumentsWithin the Custom Command Class, used to define arguments for your command. This is required only if your command requires command line arguments (obviously!). @ReferenceAnother optional - if your Custom Command Class requires reference to other services/beans. The important point to note here is that Custom Command Class (if you use the auto-magical way of setting it up) needs to have a default no-args constructor. You cannot do custom instantiation (or at least I was not able to find a way - please comment if you know how) by passing any beans/service refs your command may require to work. These can only be injected via the @Reference annotation. The reason for this is pretty straight forward, we want loose coupling (via interfaces) so that we can swap out the Services without having to change any config/wiring files. ExampleLet us create a simple command which takes in a top level directory location and recursively lists all the files and folders in it.Now we want to keep the traversal logic separate and expose it as a 'Service' from the Custom Command Class because it is a highly re-usable function.The listing below will declare a command to be used as:karaf prompt> custom:listdir 'c:\\top_level_dir\\'[codesyntax lang="java5"]package custom.command;import org.apache.karaf.shell.api.action.Action;import org.apache.karaf.shell.api.action.Argument;import org.apache.karaf.shell.api.action.Command;import org.apache.karaf.shell.api.action.lifecycle.Service;@Command(name="listdir", scope="custom", description="list all files and folders in the provided directory")@Servicepublic class DirectoryListCommand implements Action{//Inject our directory service to provide the listing.@ReferenceDirectoryService service;//Command line arguments - just one argument.@Arguments(index=0,name="topLevelDir", required=true, description="top level directory absolute path")String topLevelDirectory = null;//Creating a no-args constructor for clarity.public DirectoryListCommand(){}//Logic of the command goes here.@Overridepublic Object execute() throws Exception{// Use the directory service we injected to get the// listing and print it to the console.return "Command executed";}}[/codesyntax]The main thing in the above listing is the 'Action' interface which provides an 'execute' method to contain the logic of the command. We don't see a 'BundleContext' anywhere to help us get the Service References because we use the @Reference tag and inject what we need.This has a positive side effect of forcing us to create a Service out of the File/Directory handling functionality, thereby promoting re-use across our application. Otherwise previously we could have used the BundleActivator to initialise commands out of POJOs and register them with Karaf.Declaring the Custom CommandTo declare the presence of custom commands you need to add the following tag in the MANIFEST.MF file within the bundle:Karaf-Commands: *That will work for any command. Yes! it is a generic flag that you need to add in the Manifest. It tells Karaf that there are custom commands in this bundle.Listing below is from an actual bundle:[codesyntax lang="text"]Bundle-Name: nlp.digesterBundle-SymbolicName: rd.ml.DigesterBundle-Version: 0.0.1Karaf-Commands: *Export-Package: rd.ml.digester.service[/codesyntax]